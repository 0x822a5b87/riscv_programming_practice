# 合理使用内存屏障指令

## 无效队列

在CPU中，某个CPU在修改变量时，需要先通过 `BusRdx` 来通知其他的CPU将对应的变量的状态设置为I；

但是修改状态的效率比较低，所以CPU在执行操作计算密集型的任务时可能会延迟，所以内部设计了无效队列。

因此，CPU可以把这些让高速缓存行失效的操作缓存起来，先给请求者回复一个应答信号，再慢慢让高速缓存行失效，这样其他CPU就不必长时间等待了，这就是无效队列的核心思路

但是这样带来了一个问题，读取数据的时候需要增加一个额外的读屏障

```c++
CPU0                          CPU1
-------------------------------------------------------------
void func0()                  void func1()
{                             {
   a = 1;                        while (b == 0) continue;
   smp_wmb();
   b = 1;                        assert (a == 1)
}                             }
```

## smp_rmb(Symmetric Multi-Processing_Rrite Memory Barrier)

## smp_wmb(Symmetric Multi-Processing_Write Memory Barrier)

>在我们之前的例子中，如果我们在 `a = 1;` 之后新增一个写内存屏障，即可保证 `assert(a == 1)` 判定成功。

**核心原因：smp_wmb() 解决了 “存储缓冲区导致的写操作乱序”**

在未加内存屏障时，CPU0 可能将 a=1 暂存在存储缓冲区中，先执行 b=1，导致 CPU1 看到 b=1 时，a=1 尚未同步（仍为旧值），从而 assert 失败。

而 smp_wmb() 的作用是强制屏障前的写操作（a=1）必须在屏障后的写操作（b=1）之前 “完全可见”，具体表现为：

1. 阻止 CPU0 将 b=1 的写操作提前到 a=1 之前执行（指令乱序被禁止）；
2. 强制 CPU0 在执行 b=1 前，将存储缓冲区中 a=1 的值刷入缓存 / 主存，并通过 MESI 协议同步给其他 CPU（确保 a=1 对 CPU1 可见）。

加屏障后的执行流程（确保正确）：

1. CPU0 执行 a=1，将 a 的新值写入存储缓冲区；
2. 执行 smp_wmb()：强制将存储缓冲区中 a=1 刷入缓存 / 主存，并同步给其他 CPU（此时 a 的最新值对 CPU1 可见）；
3. CPU0 执行 b=1，b 的新值被写入缓存 / 主存；
4. CPU1 循环检测到 b=1（跳出循环），此时 a=1 已通过步骤 2 同步完成，assert(a == 1) 成功。

```c++
CPU0                           CPU1
-------------------------------------------------------------
void func0()                  void func1()
{                             {
   a = 1;                        while (b == 0) continue;
   smp_wmb();
   b = 1;                        assert (a == 1)
}                              }
```

## 什么是存储缓冲区

多核CPU下，也存在一个所谓的存储缓冲区，这个缓冲区的作用是：

在MESI协议下，通常核之间的缓存通信是基于总线的，而这个通信开销是比较高的，通常一个核的BusRd或者BusRdx信号需要等待所有的核心响应。

例如，在一个四核的CPU中，CPU0的缓存包含了数据a，并且状态为S。此时CPU0需要修改数据a。

那么CPU0会向所有的其他CPU发起BusRdx，要求所有其他的CPU都把缓存状态设置为I。

此时，CPU0在等待其他CPU响应的过程中，会进入停滞状态，严重的降低CPU的性能。

为此，CPU0会执行如下操作：

1. 将数据更新到存储缓冲区；
2. 发送总线信号。

而这也是我们之前的例子中会失败的主要原因：

1. CPU0将a=1写入存储缓冲区，发送BusUpgr信号；
2. CPU1读取b的信息，发送BusRd信号；
3. CPU0接受到BusRd信号，将数据更新到主存，并将数据通过总线同步给CPU1；
4. CPU1读取到b的最新值，跳出循环；
5. CPU1读取到a的旧值，assert 判定失败；
6. CPU1收到<1>中的BusUpgr信号，将a更新到最新值。

## 一个内存屏障的例子

>在下面的执行序列中，假设CPU0先执行a=1和b=1，然后CPU1一直循环判断b是否等于1，如果等于则跳出while循环，最后执行“assert (a == 1)”判断a是否等于1，那么assert语句有可能会失败吗？

```
CPU0                          CPU1
-------------------------------------------------------------
void func0()                  void func1()
{                             {
   a = 1;                        while (b == 0) continue;
   b = 1;                        assert (a == 1)
}                              }
```

是有可能的，最开始我认为，在MESI的限制这里是不会读取到历史数据的。实际的执行情况可以如下总结：

1. CPU1发起MESI数据同步请求；
   1.1 CPU1发起BusRd请求；
   1.2 CPU0响应BusRd请求，将数据更新到主存；
   1.3 CPU0通过总线同步数据到CPU1，并且将数据的状态设置为S。
2. CPU1从主存读取数据；

其中2.1，1.2，1.3是阻塞式的， **但是他阻塞的只是自己内部，他并不是原子的操作。** 他保证了 `1.1 -> 1.2 -> 1.3` 的执行顺序，并不能保证不出现 `1.1 -> 2 -> 1.2 -> 1.3` 的执行顺序。

也就是说，当CPU1发起MESI请求的话，他保证可以拿到最新的数据。

问题在于，弱内存模型允许 CPU1 在 “等待 MESI 同步响应” 的同时，提前使用主存中的旧值完成判断 —— 这是弱模型对 “执行顺序” 的松弛，而非 MESI 协议的失效。

也就是说，我们实际的执行可能是 2 -> 1。这种情况下就会读到历史值。

- MESI 协议的作用：确保最终所有 CPU 能看到一致的数据（即 “最终一致性”）。当 CPU1 发起 BusRd 后，CPU0 一定会将最新值同步给 CPU1，不会出现 “永久不一致” 的情况。
- 弱内存模型的影响：不强制 “数据同步完成后才能执行读取和判断”。它允许 CPU 在等待 MESI 同步的过程中，提前使用主存或本地缓存中的旧值完成判断 —— 即使后续 MESI 同步了新值，也无法改变已经执行的判断结果。

## CPU的流水线

现代的CPU有两个重要的特性：

1. 流水线执行：CPU只是一个宽泛的概念，CPU内部包含了 `取指`，`译码`，`执行`， `访存`， `写回` 等功能组件。而CPU为了执行效率通常不会等下一条指令执行完之后才开始执行，而是在`取指`执行完之后，立马取下一条指令；
2. 弱一致性模型允许乱序执行：

| 阶段 | 流水线     | 模块                                | 功能                                                                |
|----|---------|-----------------------------------|-------------------------------------------------------------------|
| 1. | 取指（IF）	 | 指令取指单元（Instruction Fetch Unit）	   | 从内存或缓存中读取下一条要执行的指令，送入译码模块。                                        |
| 2. | 译码（ID）  | 	指令译码单元（Instruction Decode Unit）	 | 将二进制指令 “翻译” 成 CPU 能理解的控制信号（比如区分 “读取操作”“加法操作” 等），同时准备操作数（如从寄存器取数）。 |
| 3. | 执行（EX）  | 	算术逻辑单元（ALU）/ 执行单元	               | 根据译码结果执行具体运算（如比较 a == 0）或发起内存请求（如 BusRd 信号）。                      |
| 4. | 访存（MEM） | 	内存访问单元（Memory Access Unit）	      | 处理与内存 / 缓存的交互（如等待 MESI 同步的新值、写入数据到内存）。                            |
| 5. | 写回（WB）  | 	写回单元（Write-Back Unit）	           | 将执行结果写回寄存器（如把 a 的最新值存入 CPU 内部寄存器，供后续指令使用）。                        |

