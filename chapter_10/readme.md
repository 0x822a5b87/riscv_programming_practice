# 内存管理

## 总结

### 64位处理器的可访问虚拟内存

>假设64位处理器的虚拟地址位宽是48位，程序员可以访问0x0000 0000 0000 0000～0x0000 FFFF FFFF FFFF以及0xFFFF 0000 0000 0000～0xFFFF FFFF FFFF FFFF这两段空间

64 位处理器若仅支持 48 位虚拟地址，并非直接使用 64 位地址的低 48 位，而是遵循 “符号扩展” 原则：
1. 虚拟地址的 最高有效位（第 47 位） 是 “符号位”；
2. 第 48 位到第 63 位（共 16 位）必须与第 47 位完全相同（即 “符号扩展填充”），这样的 64 位地址才是 “规范地址”（可被处理器识别的有效地址）；
3. 若第 48-63 位与第 47 位不同，则为 “非规范地址”（处理器视为无效地址，访问会触发异常）。

所以从这个角度，整个的虚拟内存就被分为了上面提到的两段，而 `0x0001 0000 0000 0000` 到 `0xfffe ffff ffff ffff` 的这个范围是非法的。

### CBPET(Contiguous Block PTE)

“连续块页表项”（Contiguous Block PTE，也称为 “大页” 或 “块映射”）是一种优化的页表项设计，允许单个页表项直接映射一块连续的物理内存区域（而非单个物理页帧），从而减少页表级数和内存开销，提升地址转换效率。

在常规多级页表中，每个叶子页表项（最末级）仅映射一个物理页帧（如 4KB）。而连续块页表项通过设置特定标志位（C 标志位，Contiguous），让非叶子页表项也能直接完成映射，此时该页表项对应的不是 “下一级页表”，而是 “一块连续的物理内存块”，块大小由页表级别决定：

- 例如，在 Sv39 三级页表中：
  - 常规三级页表项（叶子节点）映射 4KB 物理页；
  - 若二级页表项设置 C=1，则直接映射 2^9 × 4KB = 2MB 连续物理块（跳过三级页表）；
  - 若一级页表项设置 C=1，则直接映射 2^9 × 2MB = 1GB 连续物理块（跳过二级和三级页表）。

几个问题：

1. 这个也不一定是在页表中，也有可能是在TLB查到的。
2. 这个修改了页表的跳转逻辑，本来应该是非叶子结点的页表项，现在不指向一个子节点了，而是指向一个连续的内存块。
3. 由于2的存在，其实相当于是一个本来应该存在的虚拟内存块被占用了，如果这一块虚拟内存块后续需要使用，我们需要考虑如何将这个大块再还原到普通的页表项。

## 内存管理逻辑综述

对于多级页表来说，整体的查找流程可以简述如下：

1. 通过虚拟地址的一级索引+satp找到页表项，并从页表项跳转到二级页表；
2. 通过虚拟地址的二级索引+前面找到的地址，跳转到下级页表；
3. 循环以上过程直到找到叶子结点，通过虚拟地址的offset加上叶子结点的PFN，查找到物理内存地址。

### 术语

- `MMU` Memory Manager Unit
- `PF` Page Frame
-  `VPN` Virtual Page Number
- `PFN` Physical page Fram Number
- `PT` Page Table
- `PA` Physical Address
- `VA` Virtual Address
- `PTE` Page Table Entry
- `TLB` Translation Lookaside Buffer
- `PMA` Physical Memory Attributes ：定义物理内存区域的硬件属性，告知处理器 “如何访问” 该区域的内存（如访问方式、缓存策略等），是处理器硬件行为的 “说明书”。
- `PMP` Physical Memory Protection ：基于物理地址范围的访问权限控制，限制不同特权级（U 模式、S 模式、M 模式）对物理内存的访问（如只读、读写、执行权限），是内存安全的 “守护者”。 
- `PGD` Page Global Direcotry ： 假设riscv使用四级页表，那么 PGD，PUD，PMD 分别对应L0，L1，L2。
- `PUD` Page Upper Directory
- `PMD` Page Middle Directory


### 整体逻辑

内存被分为虚拟内存和物理内存两个不同的模块，所以虚拟内存到物理的映射需要操作系统和硬件（CPU的MMU）模块共同工作来解决。

虚拟内存的最小划分模块是页（Page），而物理内存的最小划分模块是页帧（Page Frame），他们的大小是严格的相等的。

下面是虚拟内存到物理内存的映射过程，在这里我们假设：

1. 页表是二级页表；
2. 物理内存和虚拟内存的大小都是4GB；
3. 页和页帧的大小都是4KB，也就是说，4GB的内存总共被分为`2^20`个页帧；
4. 假设一级页面有`2^8`个表项，那么每个二级页面就有`2^12`个表项，并且第N个二级页面表示的地址是 [2^24 * N, 2^24 * (N+1))；因为每一个二级表页包含了 2^12个表项，而每个表项的大小是 2^12（4kb）。也就是说第N个二级页面管理的地址应该是 N * 2^24 ~ (N+1) * 2^24 - 1

1. 操作系统为每个进程维护一个页表，页表是一个用于查找虚拟内存到物理内存的映射表。
2. 虚拟内存被分为32位，[31, 12) 位是虚拟页号，[11, 0) 位是在虚拟页号的offset。
3. 由于是二级页表，所以虚拟页号也被分为一级页表索引和二级页表索引。在这里，我们的一级索引是 [31, 23)，二级索引是 [23, 11)。我们通过这两级索引在页表中找到对应的页表项；
4. 页表项中包含了物理页帧，权限标志，有效位等信息。我们通过页表项判断：如果页表项有效，则提取物理页帧，并加载对应的物理内存：物理地址 = 物理页帧 << 页大小位数 + offset；
5. 如果页表项无效（例如尚未分配物理内存，或者被swap到硬盘），则产生一个缺页异常，此时操作系统介入：
	5.1 操作系统暂停当前进程，保存上下文；
	5.2 根据异常原因恢复内存；如果是未分配物理页帧，则分配物理页帧并初始化对应的页表项。如果是被swap到硬盘，则从硬盘加载数据到内存并设置页表项信息。
	5.3 恢复进程。

最开始的理解：

1. 对于每一个进程，每一个物理页帧都必须有一个对应的页表项用来标记该物理页帧的状态。所以假设物理内存大小为M，页帧的大小为N。那么页表项的数量就为 M / N。
2. 页表项中包含了信息物理页帧，假设页帧大小为M，而物理页帧为N，那么他管理的物理内存信息就是 M * N ~ (M+1)*N - 1。
3. 页表项只用于记录他对应的页帧的状态，例如对应的物理页帧，是否有效，权限标志等信息，具体是页帧中的哪一部分不由页表项决定，而是由PFN+虚拟内存中的offset决定。
4. 虚拟内存分为两个部分，分别是虚拟页号和虚拟页号的索引。
	4.1 虚拟页号的索引大小等于页帧的大小；
	4.2 虚拟页号会根据页表是几级页表来继续划分，假设是三级页表，那么虚拟页号也会分为一级页表索引，二级页表索引，三级页表索引。并且每个级别的索引都是和对应的页表索引是同等大小的。
5. 多级页表可以节省内存空间的原因是，在实际的生产环境中，虚拟内存并不会全部的被用到。如果使用一级页表，那么我们需要为所有的页表项分配内存。而多级页表则只需要为使用到的内存分配对应的页表项。

优化后的理解：

1. 页表项是**虚拟页**的映射记录，而非物理页的映射记录。
	1. 每个虚拟页对应一个页表项，而这个页表项对应的物理内存是否有效，由操作系统的**物理内存管理结构（例如空闲页帧链表）**来管理。页表项自身的位置和物理位置完全无关，只有它内部存储的内容，如有效位，页帧索引才和物理内存有关。
	2. 页表项的数量取决于虚拟空间大小和页大小，而非物理内存大小。例如，32 位虚拟地址空间（4GB）+4KB 页大小，无论物理内存是 1GB 还是 4GB，每个进程的页表项总数都是 4GB/4KB=2²⁰个（仅记录虚拟页的映射）。
2. 页表项中包含物理页帧号（PFN）。若页大小为 S，则该页表项对应的物理页帧管理的地址范围为 PFN × S ~ (PFN+1) × S - 1。
3. 页表项用于记录虚拟页到物理页帧的映射信息，包括对应的物理页帧号（PFN）、有效位（映射是否有效）、权限标志（读写执行权限）等。物理地址的具体位置由‘物理页帧基地址（PFN × 页大小） + 虚拟地址中的页内偏移（offset）’共同决定，页表项不直接指定页帧内的偏移。
4. 虚拟地址分为两个部分：虚拟页号（VPN）和页内偏移（offset）。
   1. 页内偏移的位数由页大小决定（如 4KB 页对应 12 位偏移），用于定位页内的具体字节；
   2. 虚拟页号会根据页表级数进一步划分（如三级页表划分为一级索引、二级索引、三级索引），各级索引的位数之和等于虚拟页号的总位数，分别用于查找对应级别的页表。
5. 多级页表可以节省内存空间的原因是，在实际的生产环境中，虚拟内存并不会全部的被用到。如果使用一级页表，那么我们需要为所有的页表项分配内存。而多级页表则只需要为使用到的内存分配对应的页表项。
6. TLB 在实际使用中，使用了 “额外标志+虚拟地址” 的方式组成了 “全局唯一的映射键”。这里额外标志就是我们的 `ASID（Address Space ID）` 。我们通过 ASID + VPN 指向唯一键，这个唯一键就是我们的PFN。我们使用PFN+offset得到PA。

## 10.4 恒等映射

>在多级页表的宏定义中，PTRS_PER_PMD 与 PTRS_PER_PGD 采用不同计算方式，本质是由 “页表大小与地址范围的强绑定关系” 决定的 —— 两种方式在数学上等价，但后者（基于地址范围）更能体现多级页表的层级逻辑，且在实际代码中更通用。

```c
// PGD的最低位的偏移量
#define PGDIR_SHIFT     30
// 单个PGD表项的大小
#define PGDIR_SIZE      (1UL << PGDIR_SHIFT)
// PGD的掩码
#define PGDIR_MASK      (～(PGDIR_SIZE - 1))
// PGD包含的表项数量
#define PTRS_PER_PGD    (PAGE_SIZE / sizeof(pgd_t))

// PMD的最低位的偏移量
#define PMD_SHIFT      21
// 单个PMD的表项大小
#define PMD_SIZE       (1UL << PMD_SHIFT)
// PMD的掩码
#define PMD_MASK       (～(PMD_SIZE - 1))
// PGDIR_SIZE = PTRS_PER_PMD * PMD_SIZE
// PTRS_PER_PMD = PGDIR_SIZE / PGD_SIZE
// PTRS_PER_PMD = (1UL << PGDIR_SHIFT) / (1UL << PMD_SHIFT)
// PTRS_PER_PMD = 1UL << (PGDIR_SHIFT - PMD_SHIFT)
#define PTRS_PER_PMD (1 << (PGDIR_SIZE - PMD_SHIFT))

// PTE最低位以及单个PTE表项大小以及对应的掩码
#define PTE_SHIFT 12
#define PTE_SIZE (1UL << PTE_SHIFT)
#define PTE_MASK (～(PTE_SIZE-1))
#define PTRS_PER_PTE (1 << (PMD_SHIFT - PTE_SHIFT))
```

### 10.4.3 创建页表

```asm
SECTIONS
{
   /*
    * 设置BenOS的加载入口地址为0x8020 0000
    */
   . = 0x80200000,
   ...
　
   /*
    * 数据段
    */
   _data = .;
   .data : { *(.data) }
   // PGD页表使用的是 [38, 30]，总共512个表项。每个表项是unsigned long long类型，大小是8个字节。所以总共大小是 4096 字节。
   . = ALIGN(4096);
   idmap_pg_dir = .;
   . += 4096;
   _edata = .;
   
   ...
}
```

下面是创建页表的函数：我们思考一下，建立一个页表我们所需要的所有信息：

1. 从 `satp` 读取到PGD页表的基地址，这个就是我们的第一个参数 `pgdir`；
2. 我们还需要物理内存的地址和虚拟内存的地址；
3. 

```c
/*
 * __create_pgd_mapping: 创建页表
 *
 * pgdir: PGD页表的基地址
 * phys: 物理地址PA
 * virt: 虚拟地址VA
 * size: 映射的大小
 * prot: 页表项PTE的属性
 * alloc_pgtable: 分配各级页表的分配函数
 * flags: 标志位
 */
static void __create_pgd_mapping(pgd_t *pgdir, unsigned long phys,
		unsigned long virt, unsigned long size,
		pgprot_t prot,
		unsigned long (*alloc_pgtable)(void),
		unsigned long flags)
{
	/* 由虚拟地址va和PGD基地址，找到对应PGD表项 */
	pgd_t *pgdp = pgd_offset_raw(pgdir, virt);
	unsigned long addr, end, next;

	phys &= PAGE_MASK;
	addr = virt & PAGE_MASK;
	end = PAGE_ALIGN(virt + size);

	do {
		/* 找到pgd表项管辖的范围*/
		next = pgd_addr_end(addr, end);
		alloc_init_pmd(pgdp, addr, next, phys,
				prot, alloc_pgtable, flags);
		phys += next - addr;
	} while (pgdp++, addr = next, addr != end);
}
```