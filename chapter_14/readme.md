# 原子操作

## 什么是原子操作

原子操作可以被认为是一个整体的，不可分割的操作。例如，对于 `a++` 这个语句，他实际的汇编代码可能如下：

```asm
ld   a0, (a1)
addi a0, a0, 1
sd   a0, (a1)
```

这个操作并不是原子的，所以可能存在如下情况导致结果异常：

1. 线程1读取a到寄存器；
2. 线程2读取a到寄存器，并且修改为b；
3. 线程1修改寄存器中的a并写回内存；

此时，内存中的值是错误的。

## 什么是LL/SC机制

LL/SC（Load-Linked / Store-Conditional，链接加载 / 条件存储）是计算机体系结构中用于实现无锁原子操作的硬件指令对，与 LR/SC（Load-Reserved / Store-Conditional）本质上是同一机制的不同命名（不同架构可能采用不同称呼，如 ARM 称 LL/SC，RISC-V 称 LR/SC）。其核心作用是通过硬件支持，在多线程 / 多核环境下实现 “读取 - 修改 - 写入”（RMW）操作的原子性，无需依赖全局锁。

## 在riscv中如何调用LR/SC指令

`LR(Load Reserved)` 和 `SC(Store Conditional)` 是基于硬件支持的一个原子操作指令。LR/SC在保留集中记录了自己需要操作的临界区的信息。 随后通过硬件能力的支持，可以知道是否有其他CPU，CPU自身或者通过DMA等方式修改了这个临界区的信息。

1. `LR` 读取数据，并且初始化一个 `Reservation Set`；
2. `SC` 更新数据，并且根据 rs 的情况来判断写入是否成功：
   1. 如果rs没有被破坏，则写入成功，将 rd 赋值为 0；
   2. 如果rs被破坏，则写入失败，将rd赋值为非0；
3. **注意，sc.w 并不会自动的跳转回lr.w，用户需要根据需求通过 `bne` 指令来手动的跳转。**

```asm
# 从 (rs1) 读取一个word到rd
lr.w rd, (rs1)
# 将 rs2 寄存器中的数据，条件存储到 rs1 指向的内存地址，如果成功则rd设置为0，否则rd不为0
sc.w rd, rs2, (rs1)
```

>此外，我们有一个需要注意的点是：`LR` 和 `SC` 只负责实现无锁原子操作，实际的逻辑需要用户自己实现，例如下面我们实现了一个简单的原子加法

```asm
; static inline void atomic_add(int i, unsigned *p);
1:
    lr.w    a2, (a1)
    addi    a2, a2, a0
    sc.w    a3, a2, (a1)
    bne     a3, x0, 1b
```

## 如果多个核同时使用LR/SC访问同一个内存地址，如何保证数据的一致性

1. CPU之间的缓存一致性，通过CPU自身的MESI机制来实现；
2. LR/SC 之间的协同，通过保留集来实现；

### 一、第一层保障：MESI 协议保证缓存层面的 “值一致性”

MESI 协议（或类似的缓存一致性协议）的核心作用是：让所有 CPU 核心对同一内存地址的缓存副本保持同步，避免出现 “一个核心改了缓存值，其他核心还在用旧缓存值” 的情况。这是 LR/SC 能正确判断 “内存是否被修改” 的基础。

具体到 LR/SC 场景：

1. 当 CPU0 执行lr.d (addr)时，会向总线发送 “读独占（Read-Exclusive）” 请求，确保其他 CPU 核心对addr的缓存副本变为 “无效（Invalid）” 状态，只有 CPU0 持有addr的有效缓存；
2. 若此时 CPU1 也执行lr.d (addr)，会触发缓存一致性检查 ——CPU0 的缓存副本已标记为 “独占”，CPU1 需等待 CPU0 释放该缓存（或让 CPU0 的缓存变为 “共享”），才能读取到addr的最新值；
3. 若某核心（如 CPU2）想修改addr的值（无论是否通过 LR/SC），会先通过 MESI 协议让其他核心对addr的缓存副本失效，确保自己修改的是 “全局最新值”，且修改后会同步到主存或其他核心的缓存。

简单说：MESI 协议保证了 “所有核心看到的addr值是一致的”，避免 LR/SC 因缓存不一致导致 “误判内存未被修改”。

### 二、第二层保障：保留集保证 LR/SC 操作的 “原子性”

保留集是每个 CPU 核心**本地维护**的 “被 LR 指令标记的内存地址集合”，其核心作用是：跟踪 “自 LR 执行后，目标内存是否被任何操作修改过”，这是 SC 指令能判断 “是否允许写入” 的关键。

具体到多核 LR/SC 竞争场景：

1. CPU0 执行lr.d (addr)后，会将addr加入自己的保留集，标记 “正在关注addr的变化”；
2. 若 CPU1 此时执行sc.d (addr, new_val)（尝试修改addr），会触发两个动作： 
   1. 先通过 MESI 协议让 CPU0 对addr的缓存副本失效（符合缓存一致性）； 
   2. 硬件会检测到 “addr已被 CPU0 的 LR 标记”，随即破坏 CPU0 的保留集（标记为 “无效”）； 
3. 当 CPU0 后续执行sc.d (addr, new_val)时，会先检查自己的保留集 —— 发现addr的保留已被破坏，直接返回失败，避免 “CPU1 已修改addr，CPU0 还写入旧值” 的竞态。

简单说：保留集是 LR/SC 的 “专属监视器”，在 MESI 保证 “值同步” 的基础上，进一步保证 “LR 到 SC 的整个过程中，内存未被其他操作干扰”，从而实现 “读取 - 修改 - 写入” 的原子性。

## LR/SC 的并行执行

> 假设我们存在一个如下的场景，我们存在CPU0和CPU1，两个CPU都会去访问同一个地址addr。
> 不同的是，CPU0会需要通过 `LR/SC` 访问并修改它，而 CPU1 只需要通过 `LR` 访问而不需要修改它。

- CPU0发起LR，CPU0会在CPU0内创建一个保留集； 
- CPU1发起LR，CPU1会在CPU1内创建一个保留集； 
- CPU0发起SC，此时保留集没有被破坏，指令执行成功；

## 什么是ABA

ABA 问题是无锁并发（尤其是基于 CAS/LR/SC 原子操作）中典型的数据一致性风险，指共享变量的值先从 “A” 被修改为 “B”，之后又被改回 “A”，此时原子操作（如 CAS）会误判 “变量未被修改”，从而错误执行更新，导致后续逻辑出现异常。

在CAS中，我们典型的实现如下：

```c++
int compare_swap(int *ptr, int expected, int new)
{
   int actual = *ptr;
   if (actual == expected) {
        *ptr = new;
   }
   return actual;
}
```

### 一、ABA 问题的核心逻辑：“值相同≠状态未变”

无锁并发中，原子操作（如 CAS）的判断依据是 “变量当前值是否等于预期的旧值”，但这个判断无法区分 “变量从未被修改” 和 “变量被修改后又恢复原值” 两种情况。具体流程如下：

1. 线程 1 读取共享变量值为 “A”，计划用 CAS（或 LR/SC）将其更新为 “C”，但因调度暂停执行；
2. 线程 2 介入，先将变量从 “A” 修改为 “B”（执行某些业务逻辑，如删除链表节点、更新计数器）；
3. 线程 2 完成逻辑后，又将变量从 “B” 改回 “A”（如重新插入链表节点、恢复计数器）；
4. 线程 1 恢复执行，通过 CAS 判断 “变量当前值仍为 A”，认为 “未被修改”，成功将其更新为 “C”，但此时变量的 “实际状态” 已因线程 2 的两次修改发生变化（如链表结构已改变），最终导致数据不一致。

### 二、典型场景：链表无锁操作中的 ABA 问题

以 “无锁链表删除节点” 为例，最易暴露 ABA 问题，流程如下：

初始链表：`A → B → C`（线程 1 计划删除节点 A）；

1. 线程 1 读取head值为 “A”（记录旧值 A，计划将head更新为 “A 的 next（即 B）”），随后暂停；
2. 线程 2 介入，先删除节点 A（head变为 B），再插入新节点 A（head变回 A，新 A 的 next 可能是 D）；
3. 线程 1 恢复，CAS 判断 “head仍为 A”，成功将head更新为 “旧 A 的 next（即 B）”；

结果：链表实际应为head → A（新）→ D，但被错误改为head → B，导致新节点 A 和 D 丢失，数据错乱。

### 三、ABA 问题的危害

ABA 问题的核心危害是 “原子操作的判断逻辑失效”—— 表面上变量值未变，实际背后的业务状态（如链表结构、资源引用、计数器上下文）已被篡改，可能导致：

- 数据丢失（如上述链表节点丢失）；
- 资源泄漏（如释放的内存被误判为未使用，重新引用）；
- 业务逻辑异常（如计数器值恢复，但中间的统计数据已错误）。

### 四、解决 ABA 问题的常见方案

针对 ABA 问题的核心 ——“值相同≠状态未变”，解决方案的本质是给变量增加 “版本信息” 或 “时间戳”，让原子操作的判断依据从 “仅值相同” 变为 “值 + 版本均相同”，具体包括： 

- 版本号机制（Versioned CAS）将共享变量设计为 “值 + 版本号” 的组合（如结构体{value: T, version: u64}），原子操作时同时判断 “值是否等于旧值” 和 “版本号是否等于旧版本号”，每次修改时不仅更新值，还递增版本号。 
  - 即使值从 A→B→A，版本号也会从 1→2→3，线程 1 会因 “版本号不匹配” 判断修改过，避免误判。 
- 标记位 / 引用计数对动态资源（如链表节点），用引用计数（如std::shared_ptr）或标记位（如 “已删除” 标记）跟踪状态，即使值恢复，标记位也能反映中间是否被修改。 
  - 避免可逆操作在业务逻辑中尽量避免 “修改后恢复原值” 的操作（如用递增的计数器代替可回退的状态），从源头减少 ABA 问题的发生场景。

### 五、一个简单的例子

```c++
struct cas_int {
    int val;
    int ver;
};

struct cas_int atomic_cas(struct cas_int *v, struct cas_int expect, int x) {
    struct cas_int actual;
    do {
        // 1. 原子读取v的val和ver（LR指令保证读取的原子性）
        // 假设lr双字指令，一次性读取val和ver到actual
        actual = lr_d(v);  // 伪指令：原子加载v的64位（val+ver）
        
        // 2. 判断是否符合预期（值和版本都匹配）
        if (actual.val != expect.val || actual.ver != expect.ver) {
            break;  // 不匹配，直接返回实际值（操作失败）
        }
        
        // 3. 构造新值（val=x，ver=actual.ver+1）
        struct cas_int new_val = {.val = x, .ver = actual.ver + 1};
        
        // 4. 原子尝试写入（SC指令保证判断和写入的原子性）
        // 若期间v未被修改（保留集未破坏），则写入成功，返回actual
        // 否则SC失败，重试
    } while (!sc_d(v, new_val));  // 伪指令：条件存储新值，失败则重试
    
    return actual;
}
```

## 保留集（reservation set）

`Reservation Set` 是LR指令在硬件层面维护的一个**动态跟踪集合**，主要的作用是判断SC指令是否能执行成功，用于保证LR/SC原子性的关键机制。

### 一、保留集的核心作用

LR/SC 指令对的目标是实现 “读取 - 修改 - 写入” 操作的原子性（如无锁更新共享变量），其逻辑如下：

1. LR 指令：读取目标内存地址的值，并在硬件中 “保留” 对该地址的访问权（记录到保留集中）；
2. 修改阶段：CPU 对读取的值进行计算（如 value + 1）；
3. SC 指令：尝试将修改后的值写回原地址。只有当保留集未被 “破坏” 时，SC 才会成功；否则失败（返回 0）。

而 保留集就是 LR 指令记录的 “被保留的内存区域”，**硬件通过跟踪保留集是否被干扰**，来判断 SC 能否安全执行。

### 二、保留集的具体内容

保留集通常是一个由硬件维护的内存地址集合（或地址范围），其范围取决于架构设计：

- 精确保留：仅包含 LR 指令访问的具体内存地址（如 4 字节变量的地址）；
- 粗粒度保留：包含该地址所在的缓存行、页，甚至更大的内存块（如 ARM 某些架构中，保留集可能是整个缓存行）。

例如，当执行 `lr.w t0, (a0)` 时，硬件会将 a0 指向的地址加入当前 CPU 的保留集。

### 三、保留集的 “破坏” 条件
SC 指令执行时，硬件会检查保留集是否 “完整”：若自 LR 执行后，保留集中的地址被任何操作（包括其他 CPU 或 DMA 控制器的访问）修改过，则保留集被 “破坏”，SC 失败；否则 SC 成功（写入新值并返回 1）。

导致保留集破坏的典型场景包括：

- 其他 CPU 写入该地址：多核心环境中，若另一个 CPU 对保留集中的地址执行写操作，当前 CPU 的保留集会被标记为无效；
- 当前 CPU 自身的其他写操作：若当前 CPU 在 LR 和 SC 之间，对保留集中的地址执行了写操作（非 SC 指令），保留集会被破坏；
- DMA 访问：外设通过 DMA 直接修改该地址，硬件会检测到并破坏保留集；
- 上下文切换：进程切换时，当前 CPU 的保留集会被清空（避免其他进程干扰）。

### 四、保留集与 LR/SC 的原子性保证

保留集的核心价值是让硬件 “记住” LR 访问的内存区域，并自动检测是否有外部干扰。通过这种机制，LR/SC 无需加锁即可实现原子操作：

- 若 SC 成功，说明从 LR 到 SC 期间，目标地址未被任何操作修改，“读取 - 修改 - 写入” 是原子的；
- 若 SC 失败，程序可重试整个 LR/SC 流程（通常用循环），直到成功。