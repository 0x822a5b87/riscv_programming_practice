# 内存屏障指令

## 术语

- `PO` Program Order
- `MO` Memory Order
- `MCM` Memory Consistency Model

## PO 和 MO

### 一、Program Order（程序顺序）

>程序顺序指的是源代码中指令的书写顺序，即程序员在代码中定义的指令执行先后关系。

对单线程程序而言，处理器会尽可能按照程序顺序执行指令（忽略编译器和硬件的优化），以保证程序的逻辑正确性。例如：

```c++
a = 1;    // 指令1
b = a + 1; // 指令2
```

程序员预期 “指令 1 先执行，指令 2 后执行”，因此b的结果应为2，这就是程序顺序的直观体现。

但在多线程或优化场景下，程序顺序可能被打破（见下文 “内存顺序”）。

### 二、Memory Order（内存顺序）

>内存顺序指的是指令在内存系统中的**实际执行顺序**和**可见性规则**，即不同线程（或处理器核心）观察到的指令执行顺序。

它由两部分决定：

- 编译器优化：编译器可能对指令重排序（如调整读写顺序）以提高效率，只要不改变单线程的执行结果（遵循 “as-if-serial” 语义）。
- 处理器硬件优化：CPU 可能采用流水线、乱序执行（Out-of-Order Execution）等技术，让指令实际执行顺序与程序顺序不同，但保证单线程内的逻辑正确。

### 三、核心差异：单线程 vs 多线程

- 单线程中：程序顺序和内存顺序通常是一致的（或表现为一致）。编译器和硬件的重排序不会破坏单线程的执行结果，因此程序员无需关心内存顺序。
- 多线程中：程序顺序和内存顺序可能不一致，导致 “线程间可见性问题”

```c++
// 线程1
a = 1;    // 指令1
flag = 1; // 指令2

// 线程2
while (flag == 1) {
    printf("%d", a); // 可能打印0？
}
```

从程序顺序看，线程 1 的 “指令 1 先于指令 2”，线程 2 预期flag=1时a已为1。但实际中：

- 编译器可能将线程 1 的指令 2 重排到指令 1 之前；
- CPU 乱序执行可能让指令 2 先写入内存。

此时线程 2 可能看到flag=1但a=0，这就是内存顺序与程序顺序不一致导致的问题。

### 四、为什么需要关注内存顺序？

多线程程序中，若不通过内存屏障（Memory Barrier） 或原子操作的内存顺序约束（如 C++11 的std::memory_order）控制内存顺序，可能出现：

- 重排序：指令执行顺序与程序顺序不符；
- 可见性问题：一个线程的写入结果不能及时被其他线程看到（因 CPU 缓存未同步）。

内存顺序的规则（如顺序一致性、释放 - 获取语义等）正是为了规范多线程间的内存交互，保证并发程序的正确性。

## 产生内存乱序访问的原因是什么

## 什么是顺序一致性内存模型

## 什么是处理器一致性内存模型

## 什么是弱一致性内存模型

## 请列出3个需要使用内存屏障指令的场景

## 什么是加载-获取内存屏障原语？什么是存储-释放内存屏障原语？

## 当多个线程正在使用同一个页表项时，如果需要更新这个页表项的内容，如何保证这些线程都能正确访问更新后的页表项？

## 请说出3个RISC-V内存屏障的约束条件

## 请简述FENCE.I指令与SFENCE.VMA指令的作用和使用场景